To convert this project into an Angular application called **Horizon Bow**, we need to follow a structured process. Below is a guide on how to set up the project, organize the code, and make the chart interactive within an Angular context.

---

# Converting Horizon Bow into an Angular Application (Updated)

This guide assumes you already have a **running Angular project** (`ng serve` works) and are ready to start feature development.

---

## **Step 0: Verify Angular Project**

Make sure your Angular project is running:

```bash
ng serve
```

Open [http://localhost:4200](http://localhost:4200) to confirm the default Angular welcome page appears.

> âœ… This ensures the base project is functional before adding chart features.

---

## **Step 1: Create a Feature Branch**

Instead of working directly on `main`, create a new branch from initial-angular-setup for this milestone:

```bash
git checkout -b feature/chart-knockout-to-angular
```

* Use the naming convention: `feature/{milestone-name}`
* Example milestone for the chart: `feature/chart-knockout-to-angular`

Commit the current state of your Angular project:

```bash
git add .
git commit -m "Initial Angular project build setup"
git push -u origin feature/chart-knockout-to-angular
```

> This will give you a clean baseline for the next development steps.

---

## **Step 2: Install Dependencies**

Install **Chart.js** and the date adapter:

```bash
 powershell -ExecutionPolicy RemoteSigned -Command "npm install chart.js chartjs-adapter-date-fns"
```
```bash
powershell -ExecutionPolicy RemoteSigned -Command "npm install chartjs-adapter-date-fns date-fns"
```
---

## **Step 3: Generate Chart Component**

Create a component for the chart:

```bash
powershell -ExecutionPolicy RemoteSigned -Command "ng generate component trajectory-chart --type=component"
```

This will create:

* `trajectory-chart.component.ts`
* `trajectory-chart.component.html`
* `trajectory-chart.component.css`
* `trajectory-chart.component.spec.ts`
---

## **Step 4: Integrate Chart Logic**

Update `trajectory-chart.component.ts` with the logic:
```typescript
   import { Component, OnInit, AfterViewInit } from '@angular/core';
import { Chart, registerables } from 'chart.js';
import 'chartjs-adapter-date-fns';

import type { ChartConfiguration } from 'chart.js';



Chart.register(...registerables);

@Component({
  selector: 'app-trajectory-chart',
  standalone: true,                   // standalone is key
  templateUrl: './trajectory-chart.component.html',
  styleUrls: ['./trajectory-chart.component.scss']
})
export class TrajectoryChartComponent implements OnInit, AfterViewInit {
  ngOnInit(): void {}

  ngAfterViewInit(): void {
    const ctx = document.getElementById('myChart') as HTMLCanvasElement;

    // Time Series Data (example)
    const entryPrice = 120;
    const targetPrice = 150;
    const horizonLengthDays = 7; // Fixed horizon length (1 week)
    const numDataPoints = 100; // More data points for finer resolution

    // Generate time series labels for 100 points (over 7 days)
    const timeSeriesLabels = [];
    const startDate = new Date('2023-01-01');
    for (let i = 0; i < numDataPoints; i++) {
      const newDate = new Date(startDate.getTime() + (i * (1000 * 60 * 60 * 24) / numDataPoints));
      timeSeriesLabels.push(newDate);
    }

    // Function to generate oscillating data with random noise (fluctuates, but trends upward)
    function generateOscillatingData(entryPrice: number, targetPrice: number, numPoints: number): number[] {
      const data = [];
      let currentPrice = entryPrice;
      const trend = (targetPrice - entryPrice) / (numPoints - 1); // The overall upward trend
      const noiseFactor = 5; // How much noise (fluctuations) to introduce, higher value increases volatility

      for (let i = 0; i < numPoints; i++) {
        const noise = (Math.random() - 0.5) * noiseFactor; // Random noise between -1 and 1
        currentPrice += trend + noise; // Apply trend and noise
        if (currentPrice < entryPrice) currentPrice = entryPrice; // Prevent price from going below entry
        if (currentPrice > targetPrice) currentPrice = targetPrice; // Prevent price from exceeding target
        data.push(currentPrice);
      }
      return data;
    }

    // More data points for actual price with oscillation
    const actualPriceData = generateOscillatingData(entryPrice, targetPrice, numDataPoints);

    // Expected price is still a straight line from entry to target
    const expectedPriceData = timeSeriesLabels.map((date, index) => {
      return entryPrice + (targetPrice - entryPrice) * (index / (numDataPoints - 1));
    });

    // Convex BÃ©zier Arc Calculation (bow shape)
    const arcData = timeSeriesLabels.map((date, index) => {
      const normalizedTime = index / (numDataPoints - 1); // Normalize to [0, 1]
      
      // Control points for BÃ©zier curve
      const controlPoint1 = entryPrice + (targetPrice - entryPrice) * 0.35 + 10;  // Control point higher than entry
      const controlPoint2 = entryPrice + (targetPrice - entryPrice) * 0.65 + 10;  // Control point higher than target

      const bezierY = Math.pow(1 - normalizedTime, 3) * entryPrice +
                      3 * Math.pow(1 - normalizedTime, 2) * normalizedTime * controlPoint1 +
                      3 * (1 - normalizedTime) * Math.pow(normalizedTime, 2) * controlPoint2 +
                      Math.pow(normalizedTime, 3) * targetPrice;

      return bezierY;
    });

    // Scalping line (exit point at 11:15am with 141-142 price)
    const scalpingStartIndex = Math.floor(numDataPoints * 0.5); // Approximate 11:15 AM (50% of the way)
    const scalpingStartPrice = 141; // Price around 141-142 at 11:15am

    // Generate the scalping line from 11:15 AM price to the expected target
    const scalpingLineData = [];
    for (let i = scalpingStartIndex; i < numDataPoints; i++) {
      const timeProgress = (i - scalpingStartIndex) / (numDataPoints - scalpingStartIndex); // Normalize for the remainder
      const scalpingPrice = scalpingStartPrice + (targetPrice - scalpingStartPrice) * timeProgress; // Smooth path
      scalpingLineData.push(scalpingPrice);
    }

    // Prepopulate scalpingLineData with placeholder values before 11:15 AM (if needed)
    for (let i = 0; i < scalpingStartIndex; i++) {
      scalpingLineData.unshift(scalpingStartPrice); // Placeholder value to start the line at the 11:15 price
    }

const config: ChartConfiguration<'line', number[], Date> = {
      type: 'line',
      data: {
        labels: timeSeriesLabels,
        datasets: [
          {
            label: 'Actual Price Progress',
            data: actualPriceData,
            borderColor: 'rgba(75, 192, 192, 1)',
            backgroundColor: 'rgba(75, 192, 192, 0.7)', // Blue background for the actual price
            fill: 'origin', // Fill below actual price
            borderWidth: 0, // Remove the line
            pointRadius: 0, // Remove plot points
            tension: 0 // Straight line, no curve
          },
          {
            label: 'Expected Price Progress (String)',
            data: expectedPriceData,
            borderColor: 'rgba(0, 0, 255, 1)',  // Blue color for expected price
            backgroundColor: 'rgba(255, 0, 0, 0.7)', // Red background for expected price
            fill: 'origin', // Fill below expected price
            borderWidth: 0, // Remove the line
            pointRadius: 0, // Remove plot points
            tension: 0.4
          },
          {
            label: 'Trajectory Arc (Bow)',
            data: arcData,
            borderColor: 'rgba(255, 159, 64, 1)', // Orange color for the arc
            backgroundColor: 'rgba(0, 255, 0, 0.2)', // Green background for the arc
            fill: 'origin', // Fill below arc
            borderWidth: 0, // Remove the line
            pointRadius: 0, // Remove plot points
            tension: 0.4,
            borderDash: [] // Solid line for the arc
          },
          {
            label: 'Scalping Exit',
            data: scalpingLineData,
            borderColor: 'rgba(255, 0, 0, 1)', // Red color for scalping exit
            backgroundColor: 'rgba(255, 0, 0, 0.3)', // Light red for the scalping area
            fill: 'origin', // Fill below scalping line
            borderWidth: 2,
            pointRadius: 0,
            tension: 0,
            borderDash: [5, 5] // Dashed line for the scalping exit
          }
        ]
      },
      options: {
        scales: {
          x: {
            type: 'time', // Time axis
            time: {
              unit: 'hour', // Use a finer granularity (hourly data points for 7 days)
              tooltipFormat: 'PPP p'
            },
            title: {
              display: true,
              text: 'Date'
            }
          },
          y: {
            title: {
              display: true,
              text: 'Price Progress (Normalized)'
            }
          }
        },
        responsive: true,
        plugins: {
          legend: {
            position: 'top',
          },
          tooltip: {
            mode: 'nearest',
            intersect: false,
            callbacks: {
              label: function(tooltipItem :any) {
                return tooltipItem.dataset.label + ': ' + tooltipItem.raw.toFixed(2);
              }
            }
          }
        }
      }
    };

    // Create the chart
    new Chart(ctx, config);
  }
}


   ```

This includes:

* Time series data generation
* Oscillating price data
* BÃ©zier arc calculation for the bow
* Scalping exit line

> Keep the logic inside `ngAfterViewInit()` so the chart renders after the view is initialized.

---

## **Step 5: Update HTML Template**

In `trajectory-chart.component.html`:

```html
<h2>Trajectory Arc with Background Fill</h2>
<canvas id="myChart"></canvas>
```

---

## **Step 6: Add Styling**

In `trajectory-chart.component.css`:

```css
canvas {
  width: 100%;
  max-width: 800px;
  margin: auto;
}
```

---

## **Step 7: Include Component in App**

Add your chart component to the main app template (`app.html`):
Find: 
```html
<h1>Hello, {{ title() }}</h1>
      <p>Congratulations! Your app is running. ðŸŽ‰</p>
```
Change to add:
```html
<h1>Hello, {{ title() }}</h1>
      <p>Congratulations! Your app is running. ðŸŽ‰</p>
<app-trajectory-chart></app-trajectory-chart>
```
---

## **Step 8: Include Component in App.ts**
```typescript
import { Component, signal } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { TrajectoryChartComponent } from './trajectory-chart/trajectory-chart.component'; // <-- child

@Component({
  selector: 'app-root',
  standalone: true,             // important for modern Angular
  imports: [RouterOutlet, TrajectoryChartComponent], // import child components here
  templateUrl: './app.html',    // template file
  styleUrls: ['./app.scss']     // styles file (plural!)
})
export class App {
  protected readonly title = signal('horizon-bow');
}
```
---

## **Step 9: Run the Application**

Start the Angular server:

```bash
powershell -ExecutionPolicy RemoteSigned -Command "ng serve"
```

Check [http://localhost:4200](http://localhost:4200) to see the chart in action.

'Ctrl + c' to exit.
---

## **Step 10: Commit and Push the Milestone**

Once the chart is rendering correctly:

```bash
git add .
git commit -m "Add trajectory chart component with initial data"
git push origin feature/chart-knockout-to-angular
```

---

## âœ… **Next Steps / Milestone Workflow**

1. For **each new feature** (e.g., dynamic data, interactivity, backend integration), create a **new branch**:

```bash
git checkout -b feature/dynamic-data
```

### Conclusion

With these changes, youâ€™ve successfully converted the **Trajectory Arc** chart into an Angular application. The Angular component will dynamically generate and display the chart, using the same logic from your provided HTML and JavaScript. You can extend this by adding features like dynamic data input, additional interactivity, or even backend integration to fetch real-time data.
